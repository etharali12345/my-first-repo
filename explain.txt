1- Make dir to store the repo in it
2- Make a clone of the repo in the cloud to the locl:
        (git clone *the copied link of repo*)
3- get inside the repo that has been cloned in the dir
4- There 4 workflows: modified -> staged -> committed -> remote
5- to see the status of the repo use the command:
        (git status)

6- Creating a file in the repo changes the status to an untracked file
7- To make the file on the track (meaning it will be part of a code committed)
        (git add fileName.extension)
8- Then we can unstage the file or commit the code using the following command:
        (git commit -m "write a message here like a new file is added")
9- all the previous changes are local, run the push command to be uploaded to the remote server
   


-----------Creating New branches----------------------------------------

1- Create a branch and move to it
        (git checkout -B branchName)

2- Create the branch but we will remain in the main
        (git branch branchName)

3-To see the current branch we're in:
        (git branch)

Note: branches exist in isolation: (main does not know the changes in the branches. Therefore, changes need to merge back to the main)

4- to push the local branch to the remote repository
        (git push -u origin branchName)
-u: will link the local branch to the remote branch on origin: Git remembers which remote branch your local branch should sync

5- To check the main (switch the branch)
        (git checkout main)
        (git switch main)
6- To receive the latest changes that were merged into it
        (git pull)

-----------in GitHub ----------------------------------------
* Make pull request so the other review the changes, after pushing the branch with its files
* Then merge the branch with the main, if being approved, delete or keep the branch. 
* The purpose of the branch is to separate the changes from the main until the team approves them.



---------- Create a repo using commands line ----------------------------------------

1- make dir ex:second-reop, get in it *cd
2- initialize the repo with the folder name
        (git init)

3-  displays the list of remote repositories & their URL || write it inside the 1st remote repo to get it URL 
    -v: ensures that both the fetch and push URLs
        (git remote -v)
4- Link MySecondRepo (local repository) to MyFirstRepo (remote GitHub repository)
    # Step 1: Navigate to MySecondRepo directory
        cd MySecondRepo  

    # Step 2: Add MyFirstRepo as a remote repository: the last line in the URL 
        git remote add origin git@github.com:GitTutorials101/MyFirstRepo.git  

    # Step 3: Verify the remote repository link
        git remote -v  

    # Step 4: Pull changes from MyFirstRepo to MySecondRepo
        git pull origin main  
    
      This directory is blank. This is because I haven't set up a branch that matches what I have on the server repository.
    # Step 5: set up a branch main on my local that tracks the branch main from the remote
        git checkout main  

--------------push and pull ----------------------------------------
    #    (git push origin main)
    When you clone a repository, Git automatically names the remote repository origin.
    Commands like (git push origin main) tell Git to push your changes to the main branch on the origin remote (the one on GitHub or wherever the repository is hosted).
    #      (git pull)
    only pulls changes for the current branch you're working on



--------------commandS specifically for GitHub CL not GIT-----------------------
#        (gh auth login)
The command is used to authenticate your GitHub CLI (gh) with your GitHub account
#         (gh repo clone <YOUR USERNAME>/<REPOSITORY-NAME> )



-------------------------.git & Head -------------------------------

Summary & Explanation:
The .git folder is responsible for tracking all changes in a Git project. One of its key components is the HEAD file, which acts as a pointer to the current branch and commit. The HEAD helps Git determine which branch you are working on.

To check the current branch and commit, you can inspect the HEAD file inside the .git directory. The refs/heads/ directory stores the commit ID of the latest commit for each branch.

Switching branches updates the HEAD pointer to reference the new branch. The git checkout command moves the HEAD to a different branch, and any new commits will update the stored commit ID.

Making changes to a file and committing it will also update the commit ID stored in refs/heads/<branch>. You can observe this change before and after committing by checking the reference file inside .git.

Git Commands Used:
1- Navigate to the .git folder:
        #   cd .git
2- View the HEAD file (check current branch):
        #   cat HEAD
3- View the commit ID of the current branch:
       #    cat .git/refs/heads/main


-------------------------DIFF & Log------------------------

1- Checking Changed Files: 
	git status: shows which files have been modified, but it does not display the actual changes.  
	git diff: goes a step further by showing what exactly has been added or removed in the modified files.  
    	this command helps track changes, avoid mistakes, and ensure code consistency across different versions.

2-  Comparing Local Changes:
    Before committing, this shows the differences between the working version (the file) and the last committed version (in the head):  
    HEAD refers to the latest commit on the current branch. 
	 #   git diff HEAD <file>

3- Comparing Commits: To see the differences between two specific commits:  
   a-To view commit history and get commit IDs.  
         #   git log
     for shorter version       
         #   git log --pretty=oneline
    b-then to see the differences;
         #   git diff <commit1_ID> <commit2_ID>

4- Comparing Branches: To check differences between two branches:  
         #   git diff <main> <branch2>


-------------------------Blame-------------------------------------
1- Tracking Changes by User:
The git blame command tracks who made specific changes to a file, when, and what was changed. It helps track contributions in a team of developers:
	#	git blame <file>
The Output:
commit_id author timestamp line_number change

2- Limiting the Output: 
Restricting the output to specific lines using (-L) flag to only display changes in a certain range.
	#	git blame -L <start_lineNum>,<end_lineNum> <file>

3- Viewing Detailed Changes:
-To see more detailed changes of a specific commit, use git log (-p)(patch: refers to changes made to the files in a commit) with the commit ID.
-hows commits from the specified commit ID up to the newest commit (the on in HEAD).
	#	git log -p <commit_id>

4- Customizing Output:
You can adjust the display format, including showing full commit hashes, email addresses, or modifying the date format with the (-l) flag.
	#	git blame -l <file>



